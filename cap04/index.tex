\chapter{Baze de date şi lucrul în echipă}
\vskip -25pt
\textit{În acest capitol vei învăţa fundamentele bazelor de date şi lucrul într-o echipă de programatori,
cu toate uneltele necesare şi unele \textit{soft skills} de care are nevoie un programator.
\vskip 1em
Scopul acestui capitol este să te pregătească pentru exerciţiul de la sfârşitul capitolului
care constă într-un proiect pe care îl vei face într-o echipă.
Începând cu acest capitol, tutorii {\phpro} mai mult te vor îndruma, te vor consilia, atât
pe tine individual, doar atunci când ai absolut nevoie, dar mai ales pe întreaga echipă.
\vskip 1em
Prin urmare, vei fi mult mai independent, dar vei şi avea o responsabilitate mai mare --
cel puţin faţă de colegii de echipă.
}
\vskip 5em

\section{Git}
\subsection{Istoria unui proiect}
Probabil că până acum te-ai confruntat deja cu următorul scenariu: vrei
să testezi ceva în programul tău, dar nu eşti sigur că schimbarea
va deveni permanentă.

Cel mai probabil te-ai folosit de comentarii în astfel de cazuri: ai comentat
o parte din codul sursă şi ai scris o nouă implementaţie dedesubt. Dacă a
fost vorba de modificări prin mai multe fişiere, probabil ai repetat acelaşi
procedeu pentru fiecare dintre acestea.

Dacă ai avut noroc, schimbările tale au fost bune, şi tot ce a trebuit să
faci în cele din urmă a fost să ştergi implementaţia veche, comentată,
şi să o laşi doar pe cea nouă în loc.

Dacă nu ai avut noroc, ţi-ai dat seama că ideea ta nu a fost cea mai grozavă,
şi a trebuit să restaurezi versiunea veche. În urma restaurării, probabil ai
avut noroc şi ai reuşit să revii la versiunea veche fără probleme.

Însă cel mai probabil, nu ai avut noroc deloc.

Ei bine, mulţumită unor programe numite \textsl{revision control systems}
(abv. RCS),
nu ai nevoie de noroc atunci când codul sursă al proiectului tău evoluează,
sau când doar vrei să testezi lucruri noi.

Cu un RCS, nu mai e nevoie să laşi la voia întâmplării modificările
aduse codului -- tot ceea ce faci este înregistrat, fiecare schimbare,
fie ea şi cât de mică. Partea bună e că poţi reveni la orice versiune
a codului, oricând, oricum!

Deşi ai multe avantaje atunci când foloseşti un RCS ca un programator singur,
RCS-urile îşi dezvoltă adevărata putere atunci când lucrezi în echipă
cu alţi programatori.

Printre cele mai cunoscute RCS-uri se numără \textit{subversion},
\textit{mercurial}, \textit{bazaar}, \textit{BitKeeper} şi \textit{git}.

În acest curs, vei folosi Git. Git s-a născut din necesitatea
programatorilor kernelului Linux de a-şi controla mai organizat
procesul de dezvoltare.

Spre deosebire de subversion, cu git nu există un server central,
de aceea git se numeşte şi DRCS, D venind de la \textsl{distributed}.

Pentru o listă a termenilor cei mai importanţi citeşte despre
\href{http://en.wikipedia.org/wiki/Revision_control}{revision control}.

\subsection{Getting started}
Sub GNU/Linux, instalarea este destul de simplă: foloseşte
package manager-ul distribuţiei tale pentru a instala pachetul "git".

Pentru Microsoft Windows,
intră pe pagina oficială\footnote{\url{http://code.google.com/p/msysgit/}}
şi instalează \textit{Full installer for official Git}. La pasul
\textit{Adjusting your PATH environment}, selectează \textit{Run
Git from the windows command prompt}. Restul opţiunilor ar trebui
să fie bune aşa cum ţi le prezintă installer-ul. Pe desktop ar trebui
să-ţi apară simbolul "git bash".

După ce ai instalat git, urmează cartea ProGit\footnote{\url{http://progit.org}},
capitolele 1-3. Aceasta îţi va prezenta mai toate noţiunile elementare
despre git.

\begin{Exercise}[title={A taste of git}]
Dacă eşti în programul de tutelare, ai deja cont pe github.com.
Acest site îţi oferă hosting pentru proiectele tale. Intră
în contact cu noi pe IRC pentru a fi îndrumat.

Crează un nou proiect pe github.com denumit după username-ul tău
de pe github.com astfel \texttt{<username>.github.com}, iar apoi
clonează-l local şi experimentează cu el.

Pentru lucrul cu repozitoriile hostate pe github, citeşte instrucţiunile
de configurare de pe github\footnote{\url{http://help.github.com/}}.

Întreabă-i pe ceilalţi cursanţi ce lucruri interesante mai poţi face
cu git.

Încearcă să te joci cât mai mult cu acest utilitar, deoarece de acum
încolo toate proiectele tale vor fi puse sub \textsl{revision control} în git.

Îţi aminteşti probabil şi de "gist-ul" unde ţi-ai salvat toate soluţiile
la exerciţii până acum. Ei bine, un "gist" nu este nimic altceva decât
un repozitoriu git. Îl poţi clona bine mersi, şi opera pe el
din confortul consolei tale -- nu e nevoie să accesezi interfaţa
web pentru a posta ceva.

Crează un fork al cărţii, fă mici corecturi acolo unde vezi necesar,
dacă ai găsit greşeli în carte, învaţă să faci pull
requests, să trimiţi patchuri, să deschizi issues pe interfaţa web
a proiectelor tale pusă la dispoziţie de github.

Investeşte în jur de 40-80 de ore de lectură şi de experimente pentru
a deveni cât de cât rutinat în folosirea acestor sisteme: git
ca utilitar de sine stătător pe de o parte, şi github.com ca
hosting pentru proiectele tale.

Un loc ideal de a experimenta cu aceste lucruri este site-ul tău
personal de pe \texttt{http://<username>.github.com/}. Încearcă
să-ţi creezi propriul site static. Cu această ocazie poţi învăţa
şi despre \textsl{sass} şi \textsl{haml} pe care le vei folosi
prin prisma \textsl{jekyll}.
\end{Exercise}

\section{Baze de date relaţionale}
Bazele de date sunt folosite pentru a salva informaţii structurate.
După structura datelor, există două cele mai răspândite forme de
baze de date:
\begin{itemize}
\item relaţionale
\item orientate pe obiecte
\end{itemize}

Bazele de date mai au încă un aspect important: mecanisme
pentru garantarea integrităţii datelor.

Bazele de date relaţionale (abv. \textsl{RDBMS}) se pretează pentru informaţii "tabelare"
ce pot avea relaţii între ele. Cele orientate pe obiecte se pretează
pentru informaţii arborescente -- gândeşte-te la arborescenţa
(şi recursivitatea) unui document HTML.

În funcţie de modul de acces, pentru ambele tipuri de mai sus există
iarăşi două categorii:
\begin{itemize}
\item de sine stătătoare
\item după arhitectura server-client
\end{itemize}

Pentru a folosi o bază de date de sine stătătoare nu ai nevoie de un
server. Baza de date constă într-un fişier care conţine toate datele
şi metadatele. Aceste baze de date pot fi trimise uşor altcuiva
şi nu este nevoie decât de un program care ştie să opereze pe acea
bază de date. Un exemplu consacrat pentru astfel de baze de date
este SQLite.

Bazele de date cu server-client au în mare trei componente:
\begin{itemize}
\item fişierul\footnote{în funcţie de RDBMS şi de alţi
factori, pot fi mai multe fişiere} efectiv în care sunt salvate
informaţiile
\item daemonul care aşteaptă conexiuni de pe internet şi
deserveşte informaţii din acele fişiere
\item clientul care se conectează la server şi cere informaţii
\end{itemize}

Atunci când clientul cere informaţii de la un server, clientul
nu primeşte toate informaţiile, pentru a-şi putea alege ce vrea.
Clientul trimite o cerere într-un limbaj special, cerere pe baza
căreia serverul generează un răspuns care conţine deja informaţiile
dorite de client.

Deşi nu este relevant pentru folosirea bazelor de date, e important
să clarificăm cum funcţionează aceste componente, şi vom încerca
să o facem pe baza cunoştinţelor pe care le avem deja despre
protocolul HTTP şi programele care îl folosesc.

Clientul DB se conectează la serverul DB printr-un protocol
de transfer al informaţiilor precum TCP/IP, similar cu
felul în care şi un browser se conectează la un daemon HTTP.

Transferul de informaţii efectiv se face într-un limbaj înţeles
de aceste două programe -- un protocol -- din nou: analog cu HTTP.

Una dintre diferenţele cruciale este însă că acest client nu se
conectează, trimite o cerere, primeşte un răspuns, şi apoi se
deconectează. Nu. Acest lucru se întâmplă în cazul protocoalelor
\textit{stateless} precum HTTP. DBMS-urile în schimb au de obicei
protocoale \textsl{stateful}, adică se conectează la daemon, şi
aceasta este menţinută până la întreruperea ei explicită.

Odată conectat, clientul e pregătit să trimită cereri formulate
într-un limbaj specific. În cazul RDBMS-urilor, predominant este
limbajul SQL (en. \textsl{Structural Query Language}
, citit \texttt{\textipa{si:kw@l}}).% IPA: siːkwəl

Această cerere formulată în limbajul SQL este apoi codată în
protocolul specific DBMS-ului şi trimisă acestuia.
Faptul că fiecare\footnote{aproape fiecare} DBMS are un protocol
specific este cauza imposibilităţii comunicării cu un daemon
de un tip folosind un client de alt tip\footnote{De exemplu,
clientul mysql.exe nu poate comunica cu un daemon postgresql.}
-- în ciuda faptului că limbajul în care e formulată cererea, SQL,
este acelaşi\footnote{Există şi aici diferenţe între sisteme,
dar limbajul în sinea lui este acelaşi, este standardizat.}.

În acest capitol vei folosi RDBMS-ul MySQL, deoarece este
cel mai des folosit în conjuncţie cu PHP.

\begin{Exercise}[title={Primii paşi în baze de date}]
\ExePart

Instalează-ţi daemonul şi clientul MySQL. Sub Microsoft
Windows poţi descărca installerul de pe site-ul
oficial\footnote{Se numeşte \textit{MySQL Community Server} şi se găseşte
la adresa \url{http://dev.mysql.com/}.}.

\ExePart

Operaţiile de bază se numesc \textit{create}, \textit{retrieve},
\textit{update}, \textit{delete}, de aici acronimul \textsl{CRUD}.

Accesează manualul MySQL\footnote{\url{http://dev.mysql.com/doc/}}
şi urmează capitolul \textit{Tutorial}. Sub Windows te vei conecta la daemon
cu clientul \texttt{mysql.exe}.

Rezervă-ţi 40-80 de ore de lucru pentru a învăţa să faci operaţii CRUD.
\end{Exercise}

\section{Comunicarea cu MySQL din runtime-ul PHP}
În loc de clientul \texttt{mysql.exe} putem folosi PHP în
calitate de client mysql. 

Desigur, PHP nu ştie de unul singur cum să comunice cu daemonul mysql,
pentru asta fiind nevoie de un modul, o extensie PHP.
Verifică dacă ai modulul \texttt{mysqli} instalat cu comanda:
\begin{verbatim}
php -m
\end{verbatim}
Sub MS Windows, poţi găsi această extensie pe site-ul
PECL\footnote{\url{http://windows.php.net/download/} says
"PECL extensions for Windows is being worked on."
%TODO check this periodically
}.

\lstinputlisting[label=lst:mysqli connect,caption={Conectarea
la MySQL}]{cap04/1-mysqli-connect.php}

Codul este destul de expresiv. Pe linia 2 obţinem o conexiune.
Pe linia 4, formulăm cererea SQL şi o trimitem conexiunii create.
Având rezultatul, îl putem citi pe tot într-un array bidimensional
cu funcţia \texttt{mysqli\_fetch\_all()} sau l-am putea citi într-o
buclă cu \texttt{mysqli\_fetch\_array()}, ceea ce ar consuma
mai puţină memorie, dar mai mult timp de procesare.

Într-un final, închidem conexiunea creată. Am fi putut totuşi să
trimitem mai multe cereri cu \texttt{mysqli\_query()} dacă am fi
avut nevoie.

Cererea SQL efectivă trimisă ţine de MySQL. Numele funcţiilor,
parametrii şi ordinea lor, cât şi tipurile de date returnate de
acestea ţin de extensia mysqli pe care ai activat-o în \texttt{php.ini}.

Dacă explorezi manualul pentru aceste funcţii, vei vedea că au
două variante, una \textit{object-oriented style} şi una
\textit{procedural style}. Noi vom folosi doar interfaţa procedurală
deocamdată, urmând ca într-un
%TODO spune care
capitol viitor să vedem cum funcţionează şi cea obiectuală.

Deşi funcţiile precum \texttt{mysqli\_connect()} returnează obiecte,
gândeşte-te deocamdată la ele ca la tipuri de date opace.
Atunci când le vezi în semnăturile funcţiilor, înseamnă că trebuie
să le pasezi ca parametri returnaţi de alte funcţii. În exemplul
nostru, un \textit{query} are nevoie de o conexiune şi returnează
un \textit{rezultat}, un \textit{fetch} are nevoie de un \textit{rezultat}
şi returnează ceva ce ştii deja cum să manipulezi: un array.

\begin{Exercise}[title={Databases explorer}]
Crează un script care primeşte de la utilizator informaţiile necesare
pentru a se conecta la un daemon MySQL şi care afişează bazele
de date deservite de acel daemon într-un tabel.

Utilizatorul va putea da click pe numele bazei de date şi va vedea
apoi un tabel cu toate tabelele din baza de date selectată.

În continuare utilizatorul va putea urma câte un link pentru fiecare
tabel pentru a vedea structura concretă a tabelului respectiv,
prezentată deasemenea în format tabelar.

Pentru generarea tabelelor foloseşte o versiune îmbunătăţită a funcţiei
\texttt{array\_table()} din exerciţiul \textit{Afişarea unui array
bidimensional}, putând astfel să reutilizezi funcţia pentru
toate tabelele generate de aplicaţia ta.

Separă view logic de business logic ca şi până acum, folosind funcţia
\texttt{render()} din exerciţiul \textit{O funcţie render()}.

Observi cum aceste funcţii te ajută să devii mai productiv? Trăiască
modularizarea codului!
\end{Exercise}

În exerciţiul anterior ai observat şi care e avantajul folosirii lui
PHP ca client mysql: poţi construi dinamic cererile SQL pe baza
inputului de la utilizator.

Atunci când vrei să interacţionezi cu baza de date într-un anumit fel,
să filtrezi rezultatele după anumite criterii, să le ordonezi sau să
le grupezi, sau să faci calcule în masă pe date, încearcă pe cât posibil
să faci asta folosind cereri SQL, şi nu PHP. Runtime-ul PHP consumă
multă memorie, iar daemonul SQL este gândit exact pentru asta: manipularea
şi salvarea datelor. Deci mergi pe mottoul \textsl{the right tool for
the job}.

%TODO lifecycle of a mysql connection in the PHP runtime -- what did I want to say??? useless, dd it

\section{Designul bazelor de date}

%TODO instalează phpMyAdmin

%TODO despre normalizare, mentioneaza cel putin algebra relationala

%TODO: spune despre domenii

%TODO de ce si cum, cand sa denormalizezi si cum, point to profiling mai jos

%TODO 1, 2 si 3rd NF, referinte la wikipedia

%TODO foreign keys, referential integrity, PKs, indexes

%TODO mysql-specific: database engine InnoDB

%TODO: ne-ar lua cateva carti ca aceasta ca sa acoperim cum trebuie subiectul
% cum trebuie, asta a fost doar o introducere
\subsection{1st NS}
%TODO write me

\subsection{2nd NF}
%TODO write me

\subsection{3rd NF}
%TODO write me



%TODO fill me

% Articole, de citit cu atenţie:
% 
% http://en.wikipedia.org/wiki/Relational_database
% 
% http://en.wikipedia.org/wiki/Database_normalization - şi articolele despre
% 1NF, 2NF şi 3NF - doar atât e suficient pentru orice programator
% 
% http://dev.mysql.com/doc/refman/5.6/en/tutorial.html - e suficient
% pentru un început
% 
% după ce ai învăţat să foloseşti clientul mysql pentru a te conecta la daemonul
% mysqld, poţi instala şi phpmyadmin şi îl folosi pe el pentru a interacţiona
% cu serverul: http://www.phpmyadmin.net/home_page/index.php
% 

\section{Debugging and profiling}
% Exerciţiu: rescrie o aplicaţie anterioară pe baze de date, cu installer, fă debugging şi profiling

\section{Lucrul în echipă}
% Pentru lucrul în echipă:
% 
% - învaţă să lucrezi cu git: http://www.ralfebert.de/tutorials/git/
% 
% 
% - apelează la echipa YAP pentru următorii paşi (IRC: irc.freenode.net / #yet-another-project)
%TODO exerciţiu: găseşte 1-2 cursanţi pe IRC de acelaşi nivel, formaţi o echipă şi creaţi un proiect mai amplu
%tutorul va fi mediatorul vostru, dar nu se va băga peste ideile voastre (cel puţin nu în mod abuziv, ci doar ca să vă prevină greşelile sau să vi le îmbunătăţească)
%dacă e nevoie, fă schimb de numere de telefon sau alte mijloace de comunicare prin voce (ex: skype) cu membrii echipei tale, pentru a înlesni comunicarea


\subsection{Norme de comunicare}
%- atunci când salvezi informaţii în repo, îi comunici ceva echipei
% nu numai mesajul, ci şi schimbările înseşi
% mesajul trebuie să reflecte exact schimbarea
%- iar schimbarea trebuie să fie una atomară:
% fie ea cât de mică, chiar şi repararea unei greşeli de exprimare, trebuie să fie salvată
% într-un commit. Dacă însă ai convenit cu colegii de echipă că vei repara toate greşelile
% de gramatică dintr-un fişier, sau ai văzut mai multe greşeli în lungul şi-n latul proiectului,
% atunci toate aceste schimbări reprezintă o "schimbare atomară"
%- un commit nu ar trebui să facă codul neparsabil (invalid dpv. sintactic), iar
% un push nici atât. De ce? Dacă faci o greşelă sintactică printre acele îmbunătăţiri
% trimise cu push, coechipierii tăi vor trebui să repare greşeala TA pentru a-şi putea
% continua munca la părţile de care sunt EI responsabili - iar asta e frustrant pentru ei.
%- gândeşte-te mereu ce vor trebui să facă colegii tăi în urma acţiunilor tale, şi fă-le
% munca cât mai plăcută. VREI ca ei să fie fericiţi, nu frustraţi, pentru că frustrările
% lor se vor întoarce împotriva ta!
%-

\subsection{Norme comportamentale}
%- nu uita că acum nu mai eşti singur. Dacă echipa eşuează, sau mai rău, întregul
%proiect eşuează, atunci şi tu porţi o vină, chiar şi pentru simplul fapt că nu
%ai observat greşeli tehnice sau organizatorice în cadrul echipei voastre, sau
%dacă le-ai observat, pentru că nu ai discutat despre ele cu partenerii tăi de lucru

%nu mai eşti responsabil faţă de tutori, ci faţă de colegii tăi de echipă. tutorii doar
%vă consiliază, ca echipă

\subsection{Development cycle}
% (ciclul iniţial) idea  => scenarii de utilizare => feature list
% db design => function design (without implementation)
% => implementation => major release

% important: nu poţi face ceva în implementarea unei funcţii care încalcă
% designul funcţiei (semnătura de parametri). Atunci când ai făcut designul ei,
% ai luat nişte decizii din anumite motive bine puse la punct.
% dacă ceva nu se poate implementa cu design-ul actual, atunci trebuie aruncat la gunoi
% întreg designul, şi refăcut, apoi se trece la o nouă implementare. Astfel se evită
% buguri introduse de schimbări făcute din mers (aşa apar majoritatea bugurilor)
% De aceea e important să faci un design bun (perfect) din start. Statistic, îţi
% poate economisi chiar şi până la 60% din resurse (timp, bani).

% after major release:
% hotfixes sunt integrate cât mai repede
% new features trec prin ciclul iniţial

%TODO: această secţiune e doar un mic sprijin pentru exerciţiul următor, nu
% o lecţie "completă" despre moduri organizatorice ale ciclului de programare

\section{Exerciţiu}
% descrierea particularităţilor exerciţiului, rolul tutorilor (doar consilieri)
% ex: găseşte-ţi colegi de echipă, găsiţi idei împreună, prezentaţi
% ideile în 2-3 pagini A4 (fontsize 12pt)

% metode de comunicare: IRC, mailing list, live voice (e.g. skype)

WRITE ME
