\chapter{Baze de date şi lucrul în echipă}
\vskip -25pt
\textit{În acest capitol vei învăţa fundamentele bazelor de date şi lucrul într-o echipă de programatori,
cu toate uneltele necesare şi unele \textit{soft skills} de care are nevoie un programator.
\vskip 1em
Scopul acestui capitol este să te pregătească pentru exerciţiul de la sfârşitul capitolului
care constă într-un proiect pe care îl vei face într-o echipă.
Începând cu acest capitol, tutorii {\phpro} mai mult te vor îndruma, te vor consilia, atât
pe tine individual, doar atunci când ai absolut nevoie, dar mai ales pe întreaga echipă.
\vskip 1em
Prin urmare, vei fi mult mai independent, dar vei şi avea o responsabilitate mai mare --
cel puţin faţă de colegii de echipă.
}
\vskip 5em

\section{Git}
\subsection{Istoria unui proiect}
Probabil că până acum te-ai confruntat deja cu următorul scenariu: vrei
să testezi ceva în programul tău, dar nu eşti sigur că schimbarea
va deveni permanentă.

Cel mai probabil te-ai folosit de comentarii în astfel de cazuri: ai comentat
o parte din codul sursă şi ai scris o nouă implementaţie dedesubt. Dacă a
fost vorba de modificări prin mai multe fişiere, probabil ai repetat acelaşi
procedeu pentru fiecare dintre acestea.

Dacă ai avut noroc, schimbările tale au fost bune, şi tot ce a trebuit să
faci în cele din urmă a fost să ştergi implementaţia veche, comentată,
şi să o laşi doar pe cea nouă în loc.

Dacă nu ai avut noroc, ţi-ai dat seama că ideea ta nu a fost cea mai grozavă,
şi a trebuit să restaurezi versiunea veche. În urma restaurării, probabil ai
avut noroc şi ai reuşit să revii la versiunea veche fără probleme.

Însă cel mai probabil, nu ai avut noroc deloc.

Ei bine, mulţumită unor programe numite \textsl{revision control systems}
(abv. RCS),
nu ai nevoie de noroc atunci când codul sursă al proiectului tău evoluează,
sau când doar vrei să testezi lucruri noi.

Cu un RCS, nu mai e nevoie să laşi la voia întâmplării modificările
aduse codului -- tot ceea ce faci este înregistrat, fiecare schimbare,
fie ea şi cât de mică. Partea bună e că poţi reveni la orice versiune
a codului, oricând, oricum!

Deşi ai multe avantaje atunci când foloseşti un RCS ca un programator singur,
RCS-urile îşi dezvoltă adevărata putere atunci când lucrezi în echipă
cu alţi programatori.

Printre cele mai cunoscute RCS-uri se numără \textit{subversion},
\textit{mercurial}, \textit{bazaar}, \textit{BitKeeper} şi \textit{git}.

În acest curs, vei folosi Git. Git s-a născut din necesitatea
programatorilor kernelului Linux de a-şi controla mai organizat
procesul de dezvoltare.

Spre deosebire de subversion, cu git nu există un server central,
de aceea git se numeşte şi DRCS, D venind de la \textsl{distributed}.

Pentru o listă a termenilor cei mai importanţi citeşte despre
\href{http://en.wikipedia.org/wiki/Revision_control}{revision control}.

\subsection{Getting started}
Sub GNU/Linux, instalarea este destul de simplă: foloseşte
package manager-ul distribuţiei tale pentru a instala pachetul "git".

Pentru Microsoft Windows,
intră pe pagina oficială\footnote{\url{http://code.google.com/p/msysgit/}}
şi instalează \textit{Full installer for official Git}. La pasul
\textit{Adjusting your PATH environment}, selectează \textit{Run
Git from the windows command prompt}. Restul opţiunilor ar trebui
să fie bune aşa cum ţi le prezintă installer-ul. Pe desktop ar trebui
să-ţi apară simbolul "git bash".

După ce ai instalat git, urmează cartea ProGit\footnote{\url{http://progit.org}},
capitolele 1-3. Aceasta îţi va prezenta mai toate noţiunile elementare
despre git.

\begin{Exercise}[title={A taste of git}]
Dacă eşti în programul de tutelare, ai deja cont pe github.com.
Acest site îţi oferă hosting pentru proiectele tale. Intră
în contact cu noi pe IRC pentru a fi îndrumat.

Crează un nou proiect pe github.com denumit la fel ca username-ul
tău de pe github.com, iar apoi clonează-l local şi experimentează
cu el.

Pentru lucrul cu repozitoriile hostate pe github, citeşte instrucţiunile
de configurare de pe github\footnote{\url{http://help.github.com/}}.

Întreabă-i pe ceilalţi cursanţi ce lucruri interesante mai poţi face
cu git.

Încearcă să te joci cât mai mult cu acest utilitar, deoarece de acum
încolo toate proiectele tale vor fi puse sub revision control în git.

Îţi aminteşti probabil şi de "gist-ul" unde ţi-ai salvat toate soluţiile
la exerciţii până acum. Ei bine, un "gist" nu este nimic altceva decât
un repozitoriu git. Îl poţi clona bine mersi, şi opera pe el
din confortul consolei tale -- nu e nevoie să accesezi interfaţa
web pentru a posta ceva.

Crează un fork al cărţii, fă mici corecturi acolo unde vezi necesar,
dacă ai găsit greşeli în carte, învaţă să faci pull
requests, să trimiţi patchuri, să deschizi issues pe interfaţa web
a proiectelor tale pusă la dispoziţie de github.

Investeşte în jur de 40-80 de ore de lectură şi de experimente pentru
a deveni cât de cât rutinat în folosirea acestor sisteme: git
ca utilitar de sine stătător pe de o parte, şi github.com ca
hosting pentru proiectele tale.
\end{Exercise}

\section{Baze de date relaţionale}
Bazele de date sunt folosite pentru a salva informaţii structurate.
După structura datelor, există două cele mai răspândite forme de
baze de date:
\begin{itemize}
\item relaţionale
\item orientate pe obiecte
\end{itemize}
Bazele de date relaţionale (abv. \textsl{RDBMS}) se pretează pentru informaţii "tabelare"
ce pot avea relaţii între ele. Cele orientate pe obiecte se pretează
pentru informaţii arborescente -- gândeşte-te la arborescenţa
(şi recursivitatea) unui document HTML.



În funcţie de modul de acces, pentru ambele tipuri de mai sus există
iarăşi două categorii:
\begin{itemize}
\item de sine stătătoare
\item după arhitectura server-client
\end{itemize}

Pentru a folosi o bază de date de sine stătătoare nu ai nevoie de un
server. Baza de date constă într-un fişier care conţine toate datele
şi metadatele. Aceste baze de date pot fi trimise uşor altcuiva
şi nu este nevoie decât de un program care ştie să opereze pe acea
bază de date. Un exemplu consacrat pentru astfel de baze de date
este SQLite.

Bazele de date cu server-client au în mare trei componente:
\begin{itemize}
\item fişierul\footnote{în funcţie de RDBMS şi de alţi
factori, pot fi mai multe fişiere} efectiv în care sunt salvate
informaţiile
\item daemonul care aşteaptă conexiuni de pe internet şi
deserveşte informaţii din acele fişiere
\item clientul care se conectează la server şi cere informaţii
\end{itemize}

Atunci când clientul cere informaţii de la un server, clientul
nu primeşte toate informaţiile, pentru a-şi putea alege ce vrea.
Clientul trimite o cerere într-un limbaj special, cerere pe baza
căreia serverul generează un răspuns care conţine deja informaţiile
dorite de client.

Deşi nu este relevant pentru folosirea bazelor de date, e important
să clarificăm cum funcţionează aceste componente, şi vom încerca
să o facem pe baza cunoştinţelor pe care le avem deja despre
protocolul HTTP şi programele care îl folosesc.

Clientul DB se conectează la serverul DB printr-un protocol
de transfer al informaţiilor precum TCP/IP, similar cu
felul în care şi un browser se conectează la un daemon HTTP.

Transferul de informaţii efectiv se face într-un limbaj înţeles
de aceste două programe -- un protocol -- din nou: analog cu HTTP.

Una dintre diferenţele cruciale este însă că acest client nu se
conectează, trimite o cerere, primeşte un răspuns, şi apoi se
deconectează. Nu. Acest lucru se întâmplă în cazul protocoalelor
\textit{stateless} precum HTTP. DBMS-urile în schimb au de obicei
protocoale \textsl{stateful}, adică se conectează la daemon, şi
aceasta este menţinută până la întreruperea ei explicită.

Odată conectat, clientul e pregătit să trimită cereri formulate
într-un limbaj specific. În cazul RDBMS-urilor, predominant este
limbajul SQL (en. \textsl{Structural Query Language}
, citit \texttt{\textipa{si:kw@l}}).% IPA: siːkwəl

Această cerere formulată în limbajul SQL este apoi codată în
protocolul specific DBMS-ului şi trimisă acestuia.
Faptul că fiecare\footnote{aproape fiecare} DBMS are un protocol
specific este cauza imposibilităţii comunicării cu un daemon
de un tip folosind un client de alt tip\footnote{De exemplu,
clientul mysql.exe nu poate comunica cu un daemon postgresql.}
-- în ciuda faptului că limbajul în care e formulată cererea, SQL,
este acelaşi\footnote{Există şi aici diferenţe între sisteme,
dar limbajul în sinea lui este acelaşi, este standardizat.}.

În acest capitol vei folosi RDBMS-ul MySQL, deoarece este
cel mai des folosit în conjuncţie cu PHP.

\begin{Exercise}[title={Primii paşi în baze de date}]
\ExePart

Instalează-ţi daemonul şi clientul MySQL. Sub Microsoft
Windows poţi descărca installerul de pe site-ul
oficial\footnote{Se numeşte \textit{MySQL Community Server} şi se găseşte
la adresa \url{http://dev.mysql.com/}.}.

\ExePart

Operaţiile de bază se numesc \textit{create}, \textit{retrieve},
\textit{update}, \textit{delete}, de aici acronimul \textsl{CRUD}.

Accesează manualul MySQL\footnote{\url{http://dev.mysql.com/doc/}}
şi urmează capitolul \textit{Tutorial}. Sub Windows te vei conecta la daemon
cu clientul \texttt{mysql.exe}.

Rezervă-ţi 40-80 de ore de lucru pentru a învăţa să faci operaţii CRUD.
\end{Exercise}

\section{Comunicarea cu MySQL din runtime-ul PHP}
%TODO mention: criterii, sortări, ordonări, grupări, se fac mereu pe DB.
%TODO lifecycle of a mysql connection in the PHP runtime

\section{Designul bazelor de date}

%TODO instalează phpMyAdmin

\subsection{1st NS}
%TODO write me

\subsection{2nd NF}
%TODO write me

\subsection{3rd NF}
%TODO write me



%TODO fill me

% Articole, de citit cu atenţie:
% 
% http://en.wikipedia.org/wiki/Relational_database
% 
% http://en.wikipedia.org/wiki/Database_normalization - şi articolele despre
% 1NF, 2NF şi 3NF - doar atât e suficient pentru orice programator
% 
% http://dev.mysql.com/doc/refman/5.6/en/tutorial.html - e suficient
% pentru un început
% 
% după ce ai învăţat să foloseşti clientul mysql pentru a te conecta la daemonul
% mysqld, poţi instala şi phpmyadmin şi îl folosi pe el pentru a interacţiona
% cu serverul: http://www.phpmyadmin.net/home_page/index.php
% 

\section{Debugging and profiling}
% Exerciţiu: rescrie o aplicaţie anterioară pe baze de date, cu installer, fă debugging şi profiling

\section{Lucrul în echipă}
% Pentru lucrul în echipă:
% 
% - învaţă să lucrezi cu git: http://www.ralfebert.de/tutorials/git/
% 
% 
% - apelează la echipa YAP pentru următorii paşi (IRC: irc.freenode.net / #yet-another-project)
%TODO exerciţiu: găseşte 1-2 cursanţi pe IRC de acelaşi nivel, formaţi o echipă şi creaţi un proiect mai amplu
%tutorul va fi mediatorul vostru, dar nu se va băga peste ideile voastre (cel puţin nu în mod abuziv, ci doar ca să vă prevină greşelile sau să vi le îmbunătăţească)
%dacă e nevoie, fă schimb de numere de telefon sau alte mijloace de comunicare prin voce (ex: skype) cu membrii echipei tale, pentru a înlesni comunicarea


\subsection{Norme de comunicare}
%- atunci când salvezi informaţii în repo, îi comunici ceva echipei
% nu numai mesajul, ci şi schimbările înseşi
% mesajul trebuie să reflecte exact schimbarea
%- iar schimbarea trebuie să fie una atomară:
% fie ea cât de mică, chiar şi repararea unei greşeli de exprimare, trebuie să fie salvată
% într-un commit. Dacă însă ai convenit cu colegii de echipă că vei repara toate greşelile
% de gramatică dintr-un fişier, sau ai văzut mai multe greşeli în lungul şi-n latul proiectului,
% atunci toate aceste schimbări reprezintă o "schimbare atomară"
%- un commit nu ar trebui să facă codul neparsabil (invalid dpv. sintactic), iar
% un push nici atât. De ce? Dacă faci o greşelă sintactică printre acele îmbunătăţiri
% trimise cu push, coechipierii tăi vor trebui să repare greşeala TA pentru a-şi putea
% continua munca la părţile de care sunt EI responsabili - iar asta e frustrant pentru ei.
%- gândeşte-te mereu ce vor trebui să facă colegii tăi în urma acţiunilor tale, şi fă-le
% munca cât mai plăcută. VREI ca ei să fie fericiţi, nu frustraţi, pentru că frustrările
% lor se vor întoarce împotriva ta!
%-

\subsection{Norme comportamentale}
%- nu uita că acum nu mai eşti singur. Dacă echipa eşuează, sau mai rău, întregul
%proiect eşuează, atunci şi tu porţi o vină, chiar şi pentru simplul fapt că nu
%ai observat greşeli tehnice sau organizatorice în cadrul echipei voastre, sau
%dacă le-ai observat, pentru că nu ai discutat despre ele cu partenerii tăi de lucru

%nu mai eşti responsabil faţă de tutori, ci faţă de colegii tăi de echipă. tutorii doar
%vă consiliază, ca echipă